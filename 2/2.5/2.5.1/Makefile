# 2.5.1 暗黙ルールを活用する
#
# ## 暗黙ルールが適用されるとき
#
# ・ターゲットが認識されていて、適用すべきルールが明示的に定義されていないとき
# ・ターゲットに対してコマンドスクリプトを書かなければよい
# ・ルールの探索は以下の順：
#     - 1. Makefileの中にルールがあるか探索
#     - 2. なければ、暗黙ルールを探索
#
#
# ## 暗黙ルールの無効化
#
# ・意図していなくても、ルールが適用されてしまうことがある
#     - 例）
#     - LISPの.lファイルを、flexの.lファイルと解釈してしまい、意図しない.oファイルを作成してしまう、など
# ・暗黙ルールの無効化
#
# ```
# %.o: %.l
# %.c: %.l
# ```
#
# ・これで暗黙ルールデータベースから取り除くことができる
# ・コマンドスクリプトを伴わないパターン = makeのデータベースからルールを取り除く役割
#
#
# ## makeの動きの流れのおさらい
#
#  1. ターゲットが決まる
#  2. ターゲットに合致するパターンを、手持ちの暗黙ルールから探す
#  3. ターゲットパターンに合致するそれぞれについて、既存のファイルから必須項目に合致するものを探す
#  4. 必須項目が見つかれば、そのルールが適用される
#  5. 見つからなければ、その必須項目を「新たなターゲット」として認識し、１に戻って再帰的に調べる
#
# ・あるターゲットパターンに対しては、ソースファイルの候補が数多く存在するものもある
#     - 例）
#     - .oファイルは、.c, .cc, .cpp, .p, .f, .r, .s, .mod などから作られる
#
#
# ## 感動的なmakeの自動実行
#
#  1. 空のyaccのソースファイルを作成
#      - touch foo.y
#  2. ciコマンドでRCSに登録
#      - ci foo.y
#  3. makeコマンドで実行ファイルfooを作る作業を見てみる
#      - make -n foo
#      - （Makefileには何も書かなくて良い）
#  4. 実行結果
#
#  ```
#  $ make -n foo
#  co  foo.y,v foo.y
#  foo.y,v  -->  foo.y
#  revision 1.1
#  done
#  yacc  foo.y
#  mv -f y.tab.c foo.c
#  cc    -c -o foo.o foo.c
#  cc   foo.o   -o foo
#  rm foo.c foo.o foo.y
#  ```
#
#  5. 暗黙ルールと必須項目の連鎖が起きている
#  6. foo.oが存在していれば、実行ファイルfooを作成できると解釈したはず
#  7. だけど無い
#  8. foo.oはfoo.cが存在していれば作成できる
#  9. foo.cはfoo.yが存在していれば作成できる
# 10. 実際に存在するfoo.y,vからチェックアウトすれば、foo.yを作成できると突き止める
# 11. この作業計画を立案して実際に実行する
# 12. 全て暗黙ルールデータベースに登録されている作業
# 13. Makefileには１文字も書いていない
#
#
# ## 中間ファイル
#
# ・ルール連鎖の中で作成されたファイル
# ・makeでは特別扱いされる
# ・中間ファイルは定義されたターゲットが存在しない -> 中間ファイルだけの更新は行わない
# ・副作用の結果なので、終了時に削除される
