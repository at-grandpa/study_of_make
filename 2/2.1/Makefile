# 2.1 明示的ルール
#
# ## 複数のターゲット
#
# 一つのルールに複数のターゲットが存在する場合、
# 全てのターゲットが同じ必須項目を持っていることになる
# どれかのターゲットが古かった場合、それらに対して同じコマンドが実行される
#
# この１行は、
#
# ```
# vpath.o variable.o: make.h config.h getopt.h gettext.h dep.h
# ```
#
# 以下の２行と同じ
#
# ```
# vpath.o: make.h config.h getopt.h gettext.h dep.h
# variable.o: make.h config.h getopt.h gettext.h dep.h
# ```
#
# ２つのターゲットはそれぞれ独立して扱われる
# 必須項目よりターゲットが古かったら、ターゲットを更新するためにコマンドが実行される
#
#
# ## ルールはどんどん追加されていく
#
# ルール構築の際、makefileを一回全て舐めるので、
# ルールを一つにして、長々と書く必要は無い
# 依存関係グラフに登録していくので、分割して必須項目を書くことができる
# （同一のターゲットには、ターゲットと必須項目をグラフに追加登録していく）
#
#
# ## 複雑な使い方
#
# ```
# # lexer.cはvpath.cがコンパイルされる前に作成されるようにする
# vpath.o: lexer.c
# ...
# # 特別のフラグ付きでvpath.cをコンパイルする
# vpath.o: vpath.c
#     $(COMPILE.c) $(RULE_FLAGS) $(OUTPUT_OPTION) $<
# ...
# # プログラムにより生成された依存関係を読み込む
# include auto-generated-dependencies.d
# ```
#
# 内容：
#   lexer.cが更新された時は、必ずvpath.oも更新されなければならない
#   そうしないと、lexer.cの更新が反映されていないvpath.oが出来上がってしまう
#   また、「ターゲットが更新される前は、必須項目が必ず新しい」ことも保証する
#   （正方向：lexer.cが更新されていたら、vpath.oを更新しなければならない）
#   （逆方向：vpath.oを作るか使うかするときは、lexer.cが最新でなくてはならない）
#   こういった必須項目の指定の仕方もある
#   実際のvpath.oのコンパイルは下に書かれている
#
#   つまり、条件追加的な立ち位置
